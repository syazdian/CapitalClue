@page "/NewComp"
@inject DialogService dialogService
@inject IStateContainer StateContainer
@inject ILocalDbRepository Localdb
@inject IFetchData FetchData

<RadzenRow JustifyContent="JustifyContent.Right" AlignItems="AlignItems.Center" class="rz-border-color-primary-darker">
    <RadzenButton Visible=@(!fetchMode) Click=@(CloseDialog) Icon="close" Size="ButtonSize.ExtraSmall" ButtonStyle="ButtonStyle.Dark">
    </RadzenButton>
</RadzenRow>
<RadzenRow JustifyContent="JustifyContent.Center" AlignItems="AlignItems.Center" class="rz-border-color-primary-darker">


    <RadzenColumn Size="12" class="rz-background-color-primary-lighter rz-color-on-info-lighter rz-text-align-center rz-p-2">
        <RadzenDataGrid @ref="fetchHistoryGrid" AllowAlternatingRows="false" AllowFiltering="false" AllowPaging="true" PageSize="5" AllowSorting="false"
                        EditMode="DataGridEditMode.Single" Data="@fetchHistoryItems" TItem="FetchHistoryDto" ColumnWidth="50px">
            <Columns>
                <RadzenDataGridColumn TItem="FetchHistoryDto" Property="Id" Title="Id" Frozen="true" />
                <RadzenDataGridColumn TItem="FetchHistoryDto" Property="StartDate" Title="StartDate" Width="100px" Frozen="true">
                    <Template Context="fetchHistory">
                        @fetchHistory.StartDate?.Date.ToString("d")
                    </Template>
                </RadzenDataGridColumn>
                <RadzenDataGridColumn TItem="FetchHistoryDto" Property="EndDate" Title="EndDate" Width="100px" Frozen="true">
                    <Template Context="fetchHistory">
                        @fetchHistory.EndDate?.Date.ToString("d")
                    </Template>
                </RadzenDataGridColumn>
                @if (fetchMode == false && confirmationDeleteMode == false)
                {
                    <RadzenDataGridColumn TItem="FetchHistoryDto" Context="fetchHistory" TextAlign="TextAlign.Right" Frozen="true">
                        <Template Context="fetchHistory">
                        <RadzenButton ButtonStyle="ButtonStyle.Danger" Icon="delete" Variant="Variant.Flat" Shade="Shade.Lighter" Size="ButtonSize.Medium" class="my-1 ms-1" Click="@(args => ConfirmationDelete(fetchHistory))" @onclick:stopPropagation="true">
                        </RadzenButton>
                    </Template>
                </RadzenDataGridColumn>
                }
            </Columns>
        </RadzenDataGrid>
    </RadzenColumn>
</RadzenRow>
@if (fetchMode == false && confirmationDeleteMode == false)
{
    <RadzenRow JustifyContent="JustifyContent.Center" AlignItems="AlignItems.Center" class=" rz-background-color-primary-lighter">
        <RadzenColumn Size="6" class="rz-text-align-center rz-p-2">
            <RadzenLabel Text="Transaction Start Date" />
            <RadzenDatePicker @bind-Value=@startDate DateFormat="MM/dd/yyyy" Change=@StartDateChaged />
        </RadzenColumn>
        <RadzenColumn Size="6" class="rz-text-align-center rz-p-2">
            <RadzenLabel Text="Transaction End Date" />
            <RadzenDatePicker @bind-Value=@endDate DateFormat="MM/dd/yyyy" Change=@EndDateChaged />
        </RadzenColumn>

    </RadzenRow>
    <RadzenRow JustifyContent="JustifyContent.Center" AlignItems="AlignItems.Center" class="rz-border-color-primary-darker">
        <RadzenColumn Size="12" class="rz-background-color-primary-lighter rz-color-on-info-lighter rz-text-align-center rz-p-2">
            <RadzenButton Click=@(ClearDates) Text="Clear Dates" Icon="refresh" Shade="Shade.Darker" ButtonStyle="ButtonStyle.Light" />
            <RadzenButton Click=@(FetchDataFromServer) Disabled=@Conflicted Text="Fetch Data" Icon="get_app" Shade="Shade.Darker" ButtonStyle="ButtonStyle.Info" />
        </RadzenColumn>
    </RadzenRow>
}
else if(fetchMode == true)
{
    <LocalDbLoader message="Loading Data ...."></LocalDbLoader>
}

@if (IsRefresh)
{
    <RadzenAlert Variant="Variant.Filled" Visible=@ShowEmptyFetch AlertStyle="AlertStyle.Warning" Size="AlertSize.Medium" Shade="Shade.Light" AllowClose=false>
        The selected time period @startDate?.Date.ToString("d") to @endDate?.Date.ToString("d") has no data to fetch.
    </RadzenAlert>
    <RadzenAlert Variant="Variant.Filled" Visible=@isTimePeriodOverlapped AlertStyle="AlertStyle.Warning" Size="AlertSize.Medium" Shade="Shade.Light" AllowClose=false>
        The selected time period has overlap with existing times, please update the dates. 
    </RadzenAlert>

    <RadzenAlert Variant="Variant.Filled" Visible=@confirmationDeleteMode AlertStyle="AlertStyle.Warning" Size="AlertSize.Medium" Shade="Shade.Light" AllowClose=false>
        <RadzenStack Orientation="Orientation.Horizontal" AlignItems="AlignItems.Center" Gap="1rem" Wrap="FlexWrap.Wrap">
            <RadzenRow JustifyContent="JustifyContent.Center" AlignItems="AlignItems.Center" class="rz-border-color-primary-darker">
                <RadzenText Text=@confirmationDeleteText></RadzenText>
            </RadzenRow>

            <RadzenRow JustifyContent="JustifyContent.Center" AlignItems="AlignItems.Center" class="rz-border-color-primary-darker">
                <RadzenButton Click=@(RemoveFetchHistory) Shade="Shade.Darker" Icon="check_circle" ButtonStyle="ButtonStyle.Success" />
                <RadzenButton Click=@(DontRemoveData) Shade="Shade.Darker" Icon="dangerous" ButtonStyle="ButtonStyle.Danger" />
            </RadzenRow>
        </RadzenStack>
    </RadzenAlert>
}
@code {
    public DateTime? startDate { get; set; } = DateTime.Today.AddDays(-30);
    public DateTime? endDate { get; set; } = DateTime.Today;
    public bool loadDatabaseInUi = false;
    public bool Conflicted = false;
    public bool isTimePeriodOverlapped = false;
    public bool fetchMode = false;
    public bool ShowEmptyFetch = false;
    public bool confirmationDeleteMode = false;
    public string confirmationDeleteText = "Are You Sure?";
    public FetchHistoryDto fetchHistoryToDelete = null;

    RadzenDataGrid<FetchHistoryDto> fetchHistoryGrid;
    List<FetchHistoryDto> fetchHistoryItems = new List<FetchHistoryDto>();

    [Parameter]
    public bool IsRefresh { get; set; } = false;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            fetchHistoryItems = await Localdb.GetFetchHistory();

        }
        catch (Exception ex)
        {

            throw;
        }


    }
    private void CloseDialog()
    {
        dialogService.Close(new FechDataDialogResult { loadDatabaseInUi = loadDatabaseInUi });

    }
    private async Task FetchDataFromServer()
    {
        ShowEmptyFetch = false;
        fetchMode = true;
        int countFetchedItems = await FetchData.FetchDataFromServerDb(startDate: startDate, endDate: endDate);
        fetchMode = false;
        StateHasChanged();

        if (countFetchedItems == 0 )
        {
            // showConfirmationDelete = true;
            // confirmationDeleteText = $"The selected time period has no data to fetch {startDate?.Date.ToString("d")} and {startDate?.Date.ToString("d")}";

            ShowEmptyFetch = true;
        }
        else
        {
            loadDatabaseInUi = true;
            fetchHistoryItems = await Localdb.GetFetchHistory();
            await fetchHistoryGrid.Reload();
            StateHasChanged();
            //dialogService.Close(true);
        }

        Conflicted = true;
    }

    private async Task ClearDates()
    {
        startDate = null;
        endDate = null;

        StateHasChanged();
    }

    public async Task EndDateChaged(DateTime? value)
    {
        var result = await Localdb.GetOverlapDates(startDate: startDate, endDate: value);
        if (result == true)
        {
            Conflicted = true;
            isTimePeriodOverlapped = true;
        }
        else
        {
            Conflicted = false;
            isTimePeriodOverlapped = false;
        }
    }

    public async Task StartDateChaged(DateTime? value)
    {
        var result = await Localdb.GetOverlapDates(startDate: value, endDate: endDate);
        if (result == true)
        {
            Conflicted = true;
            isTimePeriodOverlapped = true;
            dialogService.Refresh();
        }
        else
        {
            Conflicted = false;
            isTimePeriodOverlapped = false;
        }
    }

    private async Task ConfirmationDelete(FetchHistoryDto fetchHistory)
    {
        confirmationDeleteMode = true;
        confirmationDeleteText = $"Are you sure you want to delete data between {@fetchHistory.StartDate?.Date.ToString("d")} and {@fetchHistory.EndDate?.Date.ToString("d")}";
        fetchHistoryToDelete = fetchHistory;
        StateHasChanged();

    }

    private async Task RemoveFetchHistory()
    {
        if (fetchHistoryToDelete != null)
        {
            confirmationDeleteMode = false;
            fetchMode = true;
            await Task.Delay(1000);

            var fetchHistory = fetchHistoryToDelete;
            await Localdb.RemoveBellSourceFromLocalDbAsync(fetchHistory.StartDate, fetchHistory.EndDate);
            await Localdb.RemoveStapleSourceFromLocalDbAsync(fetchHistory.StartDate, fetchHistory.EndDate);

            await Localdb.RemoveOnlyInBellFromLocalDbAsync(fetchHistory.StartDate, fetchHistory.EndDate);
            await Localdb.RemoveOnlyInStaplesFromLocalDbAsync(fetchHistory.StartDate, fetchHistory.EndDate);
            await Localdb.RemoveInBothFromLocalDbAsync(fetchHistory.StartDate, fetchHistory.EndDate);


            await Localdb.RemoveFetchHistory(fetchHistory.Id);
            fetchHistoryItems.Remove(fetchHistory);
            await fetchHistoryGrid.Reload();

            loadDatabaseInUi = true;
            fetchHistoryToDelete = null;
            confirmationDeleteText = string.Empty;
            fetchMode = false;
            Conflicted = false;
            StateHasChanged();
        }
    }

    private async Task DontRemoveData()
    {
        confirmationDeleteMode = false;
        fetchHistoryToDelete = null;
        confirmationDeleteText = string.Empty;
        fetchMode = false;
    }

}
